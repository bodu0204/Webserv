# Webserv

## FUNCTION
###### ---------------------------------------------------------------------------------
### [tcp(7)](https://linuxjm.osdn.jp/html/LDP_man-pages/man7/tcp.7.html)
### [ip(7)](https://linuxjm.osdn.jp/html/LDP_man-pages/man7/ip.7.html)
###### ---------------------------------------------------------------------------------
### [socket(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/socket.2.html) [socket(7)](https://linuxjm.osdn.jp/html/LDP_man-pages/man7/socket.7.html)
### [setsockopt(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/getsockopt.2.html)
### [connect(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/connect.2.html)
### [bind(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/bind.2.html)
### [listen(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/listen.2.html)
### [accept(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/accept.2.html)
### [send(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/send.2.html)
### [recv(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/recv.2.html)
###### ---------------------------------------------------------------------------------
### [epoll(7)](https://linuxjm.osdn.jp/html/LDP_man-pages/man7/epoll.7.html)
### [poll(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/poll.2.html)
### [select(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/select.2.html)
###### ---------------------------------------------------------------------------------
### [fcntl(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/fcntl.2.html)
###### ---------------------------------------------------------------------------------
### [signal(7)](https://linuxjm.osdn.jp/html/LDP_man-pages/man7/signal.7.html)
### [syscalls(2)](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/syscalls.2.html)

## HTTP
### [RFC 7230](https://tex2e.github.io/rfc-translater/html/rfc7230.html)

#### 3. Message Format
>HTTP-message = start-line \*( header-field CRLF ) CRLF \[ message-body ]
* \*?? == 1個以上??をくり返えす

>HTTPメッセージを解析する通常の手順は、開始行を構造体に読み込み、各ヘッダーフィールドをフィールド名でハッシュテーブルに読み込み、空の行まで読み込んだ後、解析されたデータを使用してメッセージ本文が予想されるかどうかを判断します。

>メッセージ本文が示されている場合は、メッセージ本文の長さに等しいオクテットの量が読み取られるか、接続が閉じられるまで、ストリームとして読み取られます。

>受信者は、HTTPメッセージをUS-ASCII \[USASCII]のスーパーセットであるエンコーディングのオクテットのシーケンスとして解析する必要があります。

>送信者は、開始行と最初のヘッダーフィールドの間にホワイトスペースを送ってはならない[MUST NOT]。

>開始行と最初のヘッダーフィールドの間にホワイトスペースを受信した受信者は、メッセージを無効として拒否するか、ホワイトスペースに先行された各行をそれ以上処理せずに消費しなければならない。

#### 3.1. Start Line
>HTTP メッセージは、クライアントからサーバーへのリクエストか、サーバーからクライアントへのレスポンスのどちらかになります。構文的には、この 2 種類のメッセージは開始行がリクエスト行 (リクエストの場合) かステータス行 (レスポンスの場合) であることと、メッセージボディの長さを決定するアルゴリズム (セクション 3.3) が異なるだけです。

>理論的には、クライアントはリクエストを、サーバーはレスポンスを受け取り、その開始行の形式の違いで区別することができますが、実際には、サーバーはリクエストのみを想定し（レスポンスは不明または無効なリクエストメソッドと解釈される）、クライアントはレスポンスのみを想定して実装されています。

>start-line = request-line / status-line

#### 3.1.1. Request Line
>リクエスト行はメソッドトークンで始まり、シングルスペース（SP）、リクエストターゲット、別のシングルスペース（SP）、プロトコルバージョン、そしてCRLFで終わります。

>     request-line = method SP request-target SP HTTP-version CRLF

>メソッドトークンは、対象リソースに対して実行されるリクエストメソッドを示す。リクエストメソッドは大文字と小文字を区別する。

>     method = token
>

>request-targetは、セクション5.3で定義されるように、リクエストを適用するターゲットリソースを特定する。

>受信者は通常、リクエスト行をホワイトスペースで分割することでそのコンポーネントにパースする(セクション3.5参照)。なぜなら3つのコンポーネントに はホワイトスペースが許されないからである。残念ながら、ユーザーエージェントの中には、ハイパーテキスト参照に見られるホワイトスペースを適切にエンコードまたは除外できないものがあり、結果として、 認められない文字がリクエストターゲットで送られることになる。

>HTTPは、セクション2.5で述べられているように、リクエスト行の長さに 定義済みの制限を設けない。それが実装しているどのメソッドよりも長いメソッドを受け取るサーバーは、501 (Not Implemented)ステータスコードで応答するべきである\[SHOULD]。それがパースすることを望むどのURIよりも長いrequest-targetを受け取る サーバーは、414(URI Too Long)ステータスコードで応答しなければならない \[MUST]\(［RFC7231］のセクション6.5.12を参照)。

>リクエスト行の長さに関する様々なアドホックな制限が、実際には見受けられる。すべての HTTP 送受信者は、最低でも 8000 オクテットの リクエストライン長をサポートすることが推奨される(RECOMMENDED)。

#### 3.1.2. Status Line
>応答メッセージの最初の行はステータス行で，プロトコルバージョン，スペース（SP），ステータスコード，さらにスペース，ステータスコードを説明する空のテキストフレーズの可能性，そしてCRLFで終わります．

>     status-line = HTTP-version SP status-code SP reason-phrase CRLF

>status-code 要素は、サーバーがクライアントの対応するリクエストを理解し満足させようとした結果を記述する 3桁の整数コードである。応答メッセージの残りの部分は、そのステータスコードに対して定義されたセマンティクスに照らして解釈されるべきである。ステータスコードのクラス(1桁目で示される)、この仕様で定義されるステータス コード、新しいステータスコードの定義のための考慮事項、およびIANAレジストリなど、 ステータスコードのセマンティクスに関する情報については\[RFC7231]のセクション6を参照し てください。

>     status-code = 3DIGIT

>reason-phrase要素は、数値のステータスコードに関連するテキストの説明を 提供する目的だけのために存在する。これは、対話的なテキストクライアントで より頻繁に使用されていた以前のインターネットアプリケーションプロトコルを 尊重してのことである。クライアントはreason-phraseの内容を無視すべきです(SHOULD)。

>     reason-phrase  = *( HTAB / SP / VCHAR / obs-text )

#### 3.2. Header Fields
>各ヘッダーフィールドは、大文字小文字を区別しないフィールド名、コロン(":")、任意の先頭のホワイトスペース、フィールド値、および任意の末尾のホワイトスペースから構成されます。

>     header-field = field-name ":" OWS field-value OWS

>     field-name     = token
>     field-value    = *( field-content / obs-fold )
>     field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
>     field-vchar    = VCHAR / obs-text
>        
>     obs-fold       = CRLF 1*( SP / HTAB )
>                    ; obsolete line folding
>                    ; see Section 3.2.4

>field-nameトークンは、対応するfield-valueに、そのヘッダーフィールドで定義されたセマンティクスを持つものとしてラベル付けをする。例えば、Dateヘッダーフィールドは、\[RFC7231]のセクション7.1.1.2 で、それが出現するメッセージの生成タイムスタンプを含むものとして定義されている。

#### 3.2.1. Field Extensibility
>ヘッダーフィールドは完全に拡張可能である。新しいフィールド名 の導入には制限がなく、それぞれが新しいセマンティクスを定義すると推定される。既存のフィールドは、この仕様の各部分と、このドキュメントセット外の多くの仕様で定義されている。

>新しいヘッダーフィールドは、それらが受信者に理解されるときに、以前に定義されたヘッダーフィールドの解釈を上書きしたり強化したり、リクエスト評価の前提条件を定義したり、応答の意味を洗練させたりするように定義できる。

>プロキシは、フィールド名がConnectionヘッダーフィールド(セク ション6.1)にリストされているか、またはプロキシがそのようなフィールド をブロックするか、さもなければ変換するように特別に設定されていなければ、 認識不能なヘッダーフィールドを転送(forward)しなければならない\[MUST]。他の受信者は認識できないヘッダーフィールドを無視するべ きである\[SHOULD]。これらの要件は、配備された中継媒体の事前の更新を必要とせずに、HTTPの機能を強化することを可能にする。

>定義されたすべてのヘッダーフィールドは、\[RFC7231]のセクション8.3で述べられて いるように、「メッセージヘッダー」レジストリにIANAに登録されるべきである。

#### 3.2.2. Field Order
>異なるフィールド名を持つヘッダーフィールドを受信する順序は重要ではない。しかしながら、実装がメッセージを処理しないタイミングを可能な限り早く決定できるように、リクエストではHost、応答ではDateのような制御データを含むヘッダーフィールドを最初に送ることはグッドプラクティスである。サーバーは、リクエストヘッダーセクション全体を受け取るまで、ターゲットリソースにリクエストを適用してはならない[MUST NOT]。なぜなら、後のヘッダー フィールドは、リクエスト処理に影響を与える条件文、認証クレデンシャル、あるいは意図的に誤解を招く重複したヘッダーフィールドを含むかもしれないからである。

>送信者は、そのヘッダーフィールドのフィールド値全体がカンマ区切りのリスト \[すなわち、#(values)]として定義されているか、そのヘッダーフィールドが(以下に記すように) よく知られた例外であるかのいずれかでない限り、メッセージ中に同じフィールド名で 複数のヘッダーフィールドを生成してはならない\[MUST NOT](MUST)。

>受信者は、メッセージのセマンティクスを変えることなく、それに続く各 フィールド値をコンマで区切って順番に結合されたフィールド値に追加する ことで、同じフィールド名を持つ複数のヘッダーフィールドを一つの「field- 名: field-value」の組に結合してもよい\[MAY]。したがって、同じフィールド名を持つヘッダーフィールドを受け取る順 序は、結合されたフィールド値の解釈にとって重要である。プロキシ は、メッセージを転送(forward)するときにこれらのフィールド値の順序を変更し てはならない\[MUST NOT]。

>注：実際には、「Set-Cookie」ヘッダーフィールド(\[RFC6265])は応答メッセージに 複数回現れることが多く、リスト構文を使用しないので、同じ名前を持つ複数の ヘッダーフィールドに関する上記の要件に違反する。それは一つのフィールド値にまとめることができないので、受信者はヘッダー フィールドを処理する際に「Set-Cookie」を特別なケースとして処理するべ きである。(詳細については\[Kri2001]の付録A.2.3参照)。

#### 3.2.3. Whitespace
>本仕様では、線形空白の使用を示すために、3つの規則を使用する。OWS（オプションの空白）、RWS（必須の空白）、BWS（"悪い "空白）です。

>OWSルールは、ゼロまたはそれ以上のリニアホワイトスペースが現れるかもしれない場所で使用される。可読性を高めるためにオプションのホワイトスペースが望ましいプロトコルエレメントの場合、送信者はオプションのホワイトスペースを単一のSPとして生成すべきである(SHOULD)。そうでなければ、送信者は、インプレースメッセージフィルタリング中に無効または不要なプロトコルエレメントをホワイトアウトするために必要な場合を除き、オプションのホワイトスペースを生成すべきではない(SHOULD NOT)。

>RWS規則は、フィールドトークンを区切るために少なくとも1つの線形空白オクテットが必要な場合に使用される。送信者はRWSを単一のSPとして生成するべきである(SHOULD)。

>BWSルールは、文法が歴史的な理由から任意の空白を許可している場合に使用される。送信者はメッセージにBWSを生成してはならない[MUST NOT]。受信者は、そのような悪いホワイトスペースを解析し、プロトコルエレメントを解釈する前にそれを除去しなければならない(MUST)。

>     OWS            = *( SP / HTAB )
>                    ; optional whitespace
>     RWS            = 1*( SP / HTAB )
>                    ; required whitespace
>     BWS            = OWS
>                    ; "bad" whitespace

#### 3.2.4. Field Parsing
>メッセージは、個々のヘッダーフィールド名とは独立した、一般的なアルゴリズ ムを使ってパースされる。与えられたフィールド値内のコンテンツは、メッセージ解釈の後段 階になるまで(通常はメッセージのヘッダーセクション全体が処理された後)解析されな い。したがって、この仕様では、ABNFルールを使用して各「Field-Name:以前の版で行われたように、「フィールド名：フィールド値」のペアを定義するためにABNFルールを使用しない。その代わりに、この仕様では、登録された各フィールド名に従って名前が付けられたABNFルールを使用し、そのルールはそのフィールドの対応するフィールド値に対して有効な文法を定義する(すなわち、フィールド-値が汎用フィールドパーサーによってヘッダーセクションから抽出された後)。

>ヘッダーフィールド名とコロンの間に空白を入れることは許されない。過去には、そのような空白文字の処理の違いが、リクエストのルーティング と応答の処理におけるセキュリティの脆弱性につながったことがある。サーバーは、ヘッダーフィールド名とコロンの間にホワイトスペースを含 む受信したいかなるリクエストメッセージも、応答コード400(Bad Request)で拒否し なければならない\[MUST]。プロキシは、メッセージをダウンストリームに転送(forward)する前に、応答 メッセージからそのようなホワイトスペースをすべて削除しなければなら ない\[MUST]。

>フィールド値の前後にオプションのホワイトスペース(OWS)を入れてもよい。人間が一貫して読みやすいように、フィールド値の前に単一のSPを入れることが望ましい。フィールド値は，いかなる先頭または末尾のホワイトスペースも含まない。フィールド値の最初の非空白オクテットの前またはフィールド値の最後の非空白 オクテットの後に生じるOWSは、ヘッダーフィールドからフィールド値を抽出 するときにパーサーによって除外されなければならない。

>歴史的に、HTTPヘッダーフィールド値は、各追加行の前に少なくとも1つのスペース または水平タブ(obs-fold)を置くことで複数行に渡って拡張することができ た。この仕様では、message/httpメディアタイプ(セクション8.3.1)内を除いて、そのような行の折りたたみを非推奨とする。送信者は、メッセージがmessage/httpメディアタイプ内でのパッケージングを意図していない限り、行の折りたたみを含むメッセージ(すなわち、obs-fold規則に一致するフィールド値を含むもの)を生成してはならない(MUST NOT)。

>message/httpコンテナ内にないリクエストメッセージでobs-foldを受け取ったサーバーは、 400(Bad Request)を送ることでメッセージを拒否するか(できれば、旧式の行送りは 受け入れられないことを説明する表現を伴って)、フィールド値を解釈したりメッセージをダウンストリーム に転送する前に、受け取った各obs-foldを一つまたは複数のSPオクテットに置き換えなければ ならない(MUST)。

>message/httpコンテナ内にない応答メッセージでobs-foldを受け取るプロキシ またはゲートウェイは、メッセージを破棄して、できれば受け入れ不可能 な行の折り返しを受け取ったことを説明する表現を含む502(Bad Gateway) 応答に置き換えるか、フィールド値を解釈するかメッセージをダウンストリーム に転送する前に受け取った各obs-foldを一つまたは複数のSPオクテットに置き換えなけ ればならない\[MUST]。

>message/httpコンテナ内にない応答メッセージでobs-foldを受け取ったユーザーエージェントは、フィールド値を解釈する前に、受け取った各obs-foldを一つ以上のSPオクテットに置き換えなければならない(MUST)。

>歴史的に、HTTP は ISO-8859-1 charset \[ISO-8859-1] のテキストを持つフィールドコンテンツを許可し、他の charset は \[RFC2047] のエンコーディングによってのみサポートしてきました。実際には、ほとんどのHTTPヘッダーフィールド値はUS-ASCII文字セット\[USASCII]のサブセットのみを使用しています。新しく定義されたヘッダーフィールドは、それのフィールド値をUS-ASCIIオク テットに制限するべきである\[SHOULD]。受信者はフィールドコンテンツ(obs-text)の他のオクテットを不透 明なデータとして扱うべきである\[SHOULD]。

#### 3.2.5. Field Limits
>HTTPは、セクション2.5で述べられているように、各ヘッダーフィールド の長さまたはヘッダーセクション全体の長さに対してあらかじめ定義された制限を 設けてはいない。個々のヘッダーフィールドの長さに対する様々なアドホックな制限が実際 に見受けられ、しばしば特定のフィールドのセマンティクスに依存する。

>処理することを望むよりも大きなリクエストヘッダーフィールドまたはフィー ルドのセットを受け取るサーバーは、適切な4xx(Client Error)ステータスコードで 応答しなければならない\[MUST]。そのようなヘッダーフィールドを無視することは、リクエストスマグリン グ攻撃に対するサーバーの脆弱性を増大させることになる(セクション9.5)。

>クライアントは、ドロップされた値がメッセージのフレーミングや応答のセ マンティクスを変えることなく安全に無視できるようなフィールドセマンティクスで あれば、クライアントが処理することを望むより大きな受信ヘッダーフィールドを 廃棄または切り捨ててもよい\[MAY]。


#### 3.2.6. Field Value Components
>ほとんどのHTTPヘッダーフィールド値は、ホワイトスペースまたは特定の区切り文字で区切られた共通の構文要素（token、quoted-string、comment）を使用して定義されます。区切り文字は、トークン内で許可されていないUS-ASCIIの視覚文字のセット（DQUOTEと"(),/:;<=>?@[\]{}"）から選択されます。

>     token = 1*tchar


>     tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
>                    / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
>                    / DIGIT / ALPHA
>                    ; any VCHAR, except delimiters

>文字列が二重引用符で囲まれている場合、単一の値として解析される。

>     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
>     qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
>     obs-text       = %x80-FF

>コメントは、コメントテキストを括弧で囲むことによって、いくつかのHTTPヘッダーフィールドに含めることができます。コメントは、フィールド値の定義の一部として "comment "を含むフィールドにおいてのみ許可されます。

>     comment        = "(" *( ctext / quoted-pair / comment ) ")"
>     ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text

>バックスラッシュオクテット(" \") は、quoted-stringとコメント構成内で単一オクテット引用の仕組みとして使用できる。quoted-stringの値を処理する受信者は、quoted-pairをバックスラッシュの次のオクテットに置き換えたかのように処理しなければなりません(MUST)。

>     quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )

>送信者は、DQUOTEとその文字列内で発生するバックスラッシュオクテットを引用するために必要な場合を除き、引用符で囲まれた文字列内で引用符で囲まれたペアを生成してはならない[SHOULD NOT]。送信者は、コメント内で発生する括弧\["("と")"]とバックスラッシュオクテットを引用するために必要な 場合を除き、コメント内で引用符で囲まれたペアを生成するべきではない[SHOULD NOT]。


#### 3.3. Message Body
>HTTP メッセージのメッセージボディは (もしあれば)、そのリクエストまたは応答のペイロードボディを運ぶために使用される。メッセージボディは、セクション 3.3.1 で説明されているように転送コーディングが適用されていない限り、ペイロードボディと同一である。

>     message-body = *OCTET

>メッセージ内でメッセージボディが許可される場合のルールは、リクエストとレスポンスで異なる。

>リクエストのメッセージボディの存在は、Content-Lengthヘッダーフィールド またはTransfer-Encodingヘッダーフィールドでシグナリングされる。リクエストメッセージフレームは、メソッドがメッセージボディの用途を定義 していない場合でも、メソッドのセマンティクスから独立している。


>応答中のメッセージボディの存在は、それが応答するリクエストメソッドと応答のステータスコード(セクション3.1.2)の両方に依存する。HEADリクエストメソッド(セクション4.3.2 \[RFC7231])に対する応答は、関連する応答ヘッダーフィールド(例: Transfer-Encoding、 Content-Lengthなど)が存在すれば、その値はリクエストメソッドがGETの場合 にあったものだけを示すので、メッセージボディを決して含まない(セクション 4.3.1\[RFC7231])。CONNECTリクエストメソッドに対する2xx(Successful)応答(［RFC7231］のセク ション4.3.6)は、メッセージボディを持つ代わりにトンネルモードに切り替わる。1xx(Informational)、204(No Content)、および304(Not Modified)応答はすべて、メッセージボディを含まない。他のすべての応答はメッセージボディを含むが、ボディの長さはゼロかもしれない。

#### 3.3.1. Transfer-Encoding
>Transfer-Encodingヘッダーフィールドは、メッセージボディを形成するためにペイロードボディに適用された(または適用される)一連の転送コードに対応する転送コード名を列挙している。転送コーディングはセクション4で定義されている。

>     Transfer-Encoding = 1#transfer-coding

* 1# == 一個以上の
>Transfer-EncodingはMIMEのContent-Transfer-Encodingフィールドに類似しており、7ビットトランスポートサービス上でバイナリデータの安全なトランスポートを可能にするために設計された(\[RFC2045]、セクション6)。しかし、8ビットのクリーンな転送プロトコルでは、安全な転送は異なる焦点を持っています。HTTP の場合、Transfer-Encoding は動的に生成されるペイロードを正確に区切り、転送効率やセキュリティのためだけに適用されるペイロードエンコーディングと選択されたリソースの特徴であるエンコーディングを区別することを主な目的としています。

>受信者は chunked 転送コーディング(セクション 4.1)を解析できなければならない。なぜなら、ペイロードボディサイズが事前にわからない場合、メッセージのフレーミングにおいて重要な役割を果たすからである。送信者はメッセージボディに2回以上 chunked を適用してはならない(MUST NOT)(すなわち、既に chunked されたメッセージの chunking は許されない)。リクエストペイロードボディにchunked以外の転送符号化が適用された場合、送信者はメッセージが適切にフレーム化されることを保証するために、最後の転送符号化としてchunkedを適用しなければならない(MUST)。応答のペイロードボディに chunked 以外の転送コーディングが適用された場合、送信者は最終的な転送コーディングとして chunked を適用するか、接続を閉じることによってメッセージを終了しなければなりません(MUST)。

>     For example,
>     Transfer-Encoding: gzip, chunked
>     は、ペイロードボディが gzip 符号化により圧縮され、その後、メッセージボディを形成する際に chunked 符号化によりチャンクされたことを示す。

>Content-Encoding(RFC7231]のセクション3.1.2.1)とは異なり、 Transfer-Encodingは表現ではなくメッセージのプロパティであり、リクエスト/レスポン スの連鎖に沿った受信者は、対応する変更が Transfer-Encodingフィールド値 になされると想定し、受け取った転送コードをデコードしてもよいし、メッセージ ボディに追加転送コードを適用してもよい\[MAY]。エンコーディングパラメータに関する追加の情報は、この仕様で定義されていない 他のヘッダーフィールドで提供することができる。

>Transfer-Encodingは、リクエストが無条件にGETだった場合にオリジンサー バーがメッセージボディに転送コード(transfer coding)を適用したであろう ことを示すために、HEADリクエストに対する応答またはGETリクエストに対する 304(Not Modified) 応答(どちらもメッセージボディを含まない)で送ってもよい\[MAY](セクション 4.1 of \[RFC7232])/ \[セクション 4.2 in the GET]).しかしながら、応答連鎖の受信者(オリジンサーバーを含む)は、転送 コーディングが不要なときにそれを削除できるので、この表示は必要ない。

>サーバーは、ステータスコードが1xx(Informational)または204(No Content)のいかなる応答でも、Transfer-Encodingヘッダー フィールドを送信してはならない\[MUST NOT]。サーバーはCONNECTリクエストに対する2xx(Successful)応答でTransfer-Encoding ヘッダーフィールドを送信してはならない\[MUST NOT](参考文献\[RFC7231] のセクション4.3.6)。

>Transfer-Encoding は HTTP/1.1 で追加されました。HTTP/1.0 のサポートだけを宣伝する実装は、Transfer-Encoding のペイロードの処理方法を理解できないと一般に考えられています。クライアントは、サーバーが HTTP/1.1 (またはそれ以降) のリクエストを処理することを知っていなければ Transfer-Encoding を含むリクエストを送信してはなりません (MUST NOT)。そのような知識は、特定のユーザー設定の形式であったり、以前に受け取った応答のバージョンを記憶していたりすることがあります。サーバーは、対応するリクエストが HTTP/1.1 (またはそれ以降) を示していない限り Transfer-Encoding を含むレスポンスを送信してはなりません (MUST NOT)。

>理解できない転送コード付きのリクエストメッセージを受け取ったサーバーは、501 (Not Implemented)で応答するべきである(SHOULD)。

#### 3.3.2. Content-Length
>メッセージがTransfer-Encodingヘッダーフィールドを持たないとき、 Content-Lengthヘッダーフィールドは、想定されるペイロードボディの サイズを10進数のオクテット数で提供することができる。ペイロードボディを含むメッセージの場合、Content-Lengthフィールド値は、ボディ(とメッセージ)の終了位置を決定するために必要なフレーミング情報を提供する。ペイロードボディを含まないメッセージの場合、Content-Lengthは選択された表現のサイズを示す(【RFC7231】のセクション3)。

>     Content-Length = 1*DIGIT
>     An example is
>     Content-Length: 3495

>送信者は、Transfer-Encodingヘッダーフィールドを含むいかなるメッセージにおいても、Content-Lengthヘッダーフィールドを送信してはならない[MUST NOT]。

>ユーザーエージェントは、Transfer-Encodingが送られず、リクエストメソッドが同封のペイロードボディの意味を定義するとき、リクエストメッセージでContent-Length を送るべきである\[SHOULD]。例えば、Content-Lengthヘッダーフィールドは、値が0(ペイロードボディ が空であることを示す)の場合でも、POSTリクエストで通常送られる。リクエストメッセージがペイロードボディを含まず、メソッドのセマンティクスがそのようなボディを予期しない場合、ユーザーエージェントはContent-Lengthヘッダーフィールドを送るべきではない[SHOULD NOT]。

>サーバーは、HEADリクエストに対する応答でContent-Lengthヘッダーフィー ルドを送ってもよい\[MAY](参考文献\[RFC7231]のセクション4.3.2)。サーバーは、そのフィールド値が、同じリクエストがGETメソッドを使った場合に応答のペイ ロードボディで送られたであろう10進数のオクテットと等しくない限り、そのような応答でContent-Lengthを送るべきではない[MUST NOT]。

>サーバーは、条件付きGETリクエストに対する304(Not Modified)応答で、 Content-Lengthヘッダーフィールドを送ってもよい\[MAY] (\[RFC7232]のセクション 4.1); そのような応答ではContent-Lengthを送ってはならない[MUST NOT] 。

>ただし、そのフィールド値が、同じリクエストに対する200(OK)応答のペイロードボディで送られたであろう10進数のオクテットに等しい場合はこの限りではない。

>サーバーは、ステータスコードが1xx(Informational)または204(No Content)のいかなる応答でも、Content-Lengthヘッダーフィー ルドを送信してはならない[MUST NOT]。サーバーは、CONNECTリクエストに対するいかなる2xx(Successful)応答でも、Content-Lengthヘッダーフィールドを送信してはならない\[MUST NOT](\[RFC7231]のセクション4.3.6)。

>上記で定義された場合を除き、Transfer-Encodingがない場合、オリジンサーバー は、完全なヘッダーセクションを送る前にペイロードボディサイズが分かってい るときは、Content-Lengthヘッダーフィールドを送るべきである\[SHOULD]。これにより、ダウンストリームの受信者は、転送の進捗を測定し、受信した メッセージがいつ完了したかを知り、追加のリクエストのために接続を再利用 できる可能性がある。

>0以上のいかなるContent-Lengthフィールド値も有効である。ペイロードの長さにあらかじめ定義された制限はないので、受信者は、潜在的に大きな10進数 を予期し、整数変換のオーバーフローによるパースエラーを防がなければならない\[MUST] (セクション9.3)。

>同じ10進数値からなるフィールド値を持つ複数のContent-Lengthヘッダーフィールド、または同一の10進数値のリストを含むフィールド値を持つ単一のContent-Lengthヘッダーフィールドを持つメッセージを受け取った場合 (例: 「Content-Length: 42, 42」)。「受信者は、メッセージボディの長さを決定したりメッセージを転送する前に、 メッセージを無効として拒否するか、重複したフィールド値を、その10進値を含む単一の有効なContent-Lengthフィールドに置き換えなければならない\[MUST]。

>注意: HTTP のメッセージフレームングのための Content-Length の使用は、同じフィールドが "message/external-body" メディアタイプの中だけで使われるオプションフィールドである MIME での使用と大きく異なっています。

#### 3.3.3. Message Body Length
>メッセージボディの長さは、以下のいずれか（優先順位）により決定される。

>1.HEADリクエストに対する応答、および1xx(Informational)、204(No Content)、304 (Not Modified)のいずれかのステータスコードを持つ応答は、メッセージに存在するヘッダー フィールドに関わらず、常にヘッダーフィールドの後の最初の空行で終了し、そ れゆえメッセージボディを含むことができない。

>2.CONNECTリクエストに対するいかなる2xx(Successful)応答も、ヘッダーフィー ルドを終了する空の行の直後に、その接続がトンネルになることを暗黙に示 す。クライアントは、そのようなメッセージで受け取ったいかなるContent-Length またはTransfer-Encodingヘッダーフィールドも無視しなければならない\[MUST]。

>3.Transfer-Encodingヘッダーフィールドが存在し、チャンク転送コーディング（セクション 4.1）が最終エンコーディングである場合、メッセージボディ長は転送コーディングがデータ完了を示すまでチャンクデータを読み、デコードすることによって決定される。

>もしTransfer-Encodingヘッダーフィールドが応答中に存在し、chunked転送コーディングが最終エンコーディングでない場合、メッセージボディの長さはサーバーによって閉じられるまでコネクションを読み取ることによって決定される。Transfer-Encodingヘッダーフィールドがリクエストに存在し、chunked転送コーディングが最終エンコーディングでない場合、メッセージボディの長さを確実に決定する ことはできない。サーバーは400 (Bad Request)ステータスコードで応答し、その後コネクションを閉鎖しなければならない\[MUST]。

>Transfer-EncodingとContent-Lengthヘッダーフィールドの両方を持つメッセージを 受け取った場合、Transfer-EncodingはContent-Lengthをオーバーライドす る。そのようなメッセージは、リクエストの密輸(セクション9.5)または応答の 分割(セクション9.4)を実行する試みを示すかもしれず、エラーとして扱われ るべきである。送信者は、そのようなメッセージをダウンストリームに転送(forward)する 前に、受け取ったContent-Lengthフィールドを削除しなければならない\[MUST]。

>4.4. Transfer-Encodingなしで、かつ、異なるフィールド値を持つ複数の Content-Lengthヘッダーフィールドまたは無効な値を持つ一つのContent-Lengthヘッダーフィールドを持つメッセージを受け取った場合、メッセージのフレーム化は無効であり、受信者はそれを回復不能エラーとして扱わなければならない\[MUST]。これがリクエストメッセージの場合、サーバーは400(Bad Request)ステータスコードで応答し、それからコネクションを閉じなければならない\[MUST]。これがプロキシによって受け取られた応答メッセージの場合、プロキシはサーバーとの接続を閉じて、受け取った応答を破棄し、クライアントに502(Bad Gateway)応答を送らなければならない\[MUST]。これがユーザーエージェントによって受け取られた応答メッセージである場合、 ユーザーエージェントはサーバーへの接続を閉じ、受け取った応答を破棄しなければならない\[MUST]。

>5.Transfer-Encodingなしで有効なContent-Lengthヘッダーフィールドが存在する 場合、その10進値は予想されるメッセージボディの長さをオクテットで定義す る。示されたオクテット数を受信する前に送信者が接続を閉じるか、受信者がタイムアウトした場合、受信者はメッセージを不完全なものとみなして接続を閉じなければならない\[MUST]。

>6.リクエストメッセージで、上記のいずれにも当てはまらない場合、メッセージボディの長さは0である（メッセージボディが存在しない）。

>7.それ以外の場合は、メッセージボディ長が宣言されていない応答メッセージであるため、メッセージボディ長は、サーバが接続を閉じる前に受信したオクテット数によって決定される。

>正常に完了したclose-delimitedメッセージと、ネットワーク障害によって中断された部分的に受信したメッセージとを区別する方法はないので、サーバーは可能な限りエンコーディングまたは長さで区切られたメッセージを生成すべきです(SHOULD)。close-delimiting機能は、主にHTTP/1.0との下位互換のために存在します。

>サーバーは、メッセージボディを含むがContent-Lengthを含まないリクエストを、411(Length Required)で応答することで拒否してもよい\[MAY]。

>chunked以外の転送コーディングが適用されていなければ、メッセージボディを含むリクエストを送るクライアントは、chunked転送コーディングではなく、メッセージボディの長さが事前に分かっている場合には有効なContent-Lengthヘッダーフィールドを使用するべきである\[SHOULD]。既存のいくつかのサービスは、チャンク転送コーディングを理解していても411(Length Required)というステータスコードでchunkedに対して応答するためである。これは、そのようなサービスが、呼び出される前にあらかじめcontent-lengthを要求するゲートウェイを介して実装されており、サーバーが処理前にリクエスト全体をバッファリングできない、またはしたくないことが典型的な理由である。

>メッセージボディを含むリクエストを送るユーザーエージェントは、サーバーがHTTP/1.1(またはそれ以降)のリクエストを処理することを知らない場合、有効なContent-Lengthヘッダーフィールドを送らなければならない\[MUST]。そのような知識は、特定のユーザー設定の形でも、以前に受け取った応答のバージョンを記憶している形でも構わない。

>あるコネクションの最後のリクエストに対する最終応答が完全に受け取られ、読むべき追加のデータが残っている場合、ユーザーエージェントは残りのデータを捨ててもよい\[MAY]。あるいは、そのデータが以前の応答ボディの一部として属するかどうかを決定しようと試みてもよい\[MAY]（以前のメッセージのContent-Length値が間違っているとそうなる可能性がある）。クライアントはそのような余分なデータを別の応答として処理、キャッシュ、転送してはならない[MUST NOT]。そのような動作はキャッシュポイズニングに対して脆弱になるからである。

#### 3.4. Handling Incomplete Messages
>通常、キャンセルされたリクエストやトリガーされたタイムアウト例外のために、不完全なリクエストメッセージを受け取ったサーバーは、コネクションを閉じる前にエラー応答を送ってもよい\[MAY]。

>不完全な応答メッセージを受け取ったクライアントは、コネクションが早期に切断されたときや、本来ならチャンクされた転送コーディングのデコードに失敗したときに起こり得ることですが、メッセージを不完全なものとして記録しなければなりません(MUST)。不完全な応答に対するキャッシュの要件は、\[RFC7234]のセクション3で定義されています。

>応答がヘッダーセクションの途中(空の行を受け取る前)で終了し、ステータスコードが応答の完全な意味を伝えるためにヘッダーフィールドに依存するかもしれない場合、クライアントはその意味が伝えられたと仮定することはできない。

>チャンク転送符号化を使用するメッセージボディは，符号化を終了するゼロサイズのチャンクを受信していない場合，不完全である。有効なContent-Lengthを使用するメッセージは，受信したメッセージボディのサイズ（オクテット単位）がContent-Lengthで指定された値より小さい場合，不完全である。チャンク転送符号化もContent-Lengthも持たない応答は，コネクションの閉鎖によって終了するため，受信したメッセージボディのオクテット数にかかわらず，ヘッダーセクションをそのまま受信すれば，完全であると見なされる。

#### 3.5. Message Parsing Robustness
>古いHTTP/1.0ユーザーエージェントの実装では、行末で終了しないメッセージボディコンテンツを読めない初期のサーバーアプリケーションを回避するために、POSTリクエストの後に余分なCRLFを送るかもしれません。HTTP/1.1ユーザーエージェントは、リクエストの前に余分なCRLFを付けてはならない\[MUST NOT]。リクエストメッセージボディを行末で終了することが望まれる場合、ユーザーエージェントは終了するCRLFオクテットをメッセージボディ長の一部としてカウントしなければならない(MUST)。

>堅牢性の観点から、リクエスト行を受信して解析することを期待しているサーバーは、リクエスト行の前に受信した少なくとも1つの空行(CRLF)を無視するべきである\[SHOULD]。

>開始行とヘッダーフィールドの行末はCRLFであるが、受信者は単一のLFを行末として認識し、先行するCRを無視してもよい\[MAY]。

>リクエスト行とステータス行の文法規則は、各構成要素を1つのSPオクテットで区切ることを要求するが、受信者は代わりに空白で区切られた単語境界で解析してもよい\[MAY]。CRLFターミネーターを除いて、任意の形式の空白を、先行または後続の空白を無視しながらSPセパレータとして処理する。SP, HTAB, VT (%x0B), FF (%x0C), または裸のCR.ただし、メッセージの受信者が複数いて、それぞれが堅牢性について独自の解釈をしている場合、甘い解析はセキュリティ上の脆弱性をもたらす可能性がある（セクション9.5を参照）。

>HTTPリクエストメッセージのみをリスニングしているサーバーや、スタートラインからHTTPリクエストメッセージに見えるものを処理するサーバーが、上記の堅牢性の例外を除いてHTTPメッセージの文法にマッチしないオクテットのシーケンスを受け取った場合、400(Bad Request) 応答で応答すべきです(SHOULD)。

























## HTTPS
### [RFC 2818](https://tex2e.github.io/rfc-translater/html/rfc2818.html)
#### 2. HTTP Over TLS
>TCP上でHTTPを使用するのと同じように、単に正確にTLS上でHTTPを使用します。

## TLS
### [RFC 8446](https://tex2e.github.io/rfc-translater/html/rfc8446.html)
#### 1. Introduction
>TLSは、2つの主要なコンポーネントで構成されています。
>- 通信相手を認証し、暗号化モードとパラメーターをネゴシエートし、共有キー情報を確立するハンドシェイクプロトコル（セクション4）。 ハンドシェイクプロトコルは、改ざんに耐えるように設計されています。 アクティブな攻撃者は、接続が攻撃を受けていない場合にピアとは異なるパラメータをネゴシエートさせることはできません。
>- ハンドシェイクプロトコルによって確立されたパラメータを使用して、通信するピア間のトラフィックを保護するレコードプロトコル（セクション5）。 レコードプロトコルは、トラフィックを一連のレコードに分割します。各レコードは、トラフィックキーを使用して個別に保護されます。
* ネゴシエート: 交渉

#### 2. Protocol Overview
>セキュアチャネルで使用される暗号化パラメーターは、TLSハンドシェイクプロトコルによって生成されます。 

>TLSのこのサブプロトコルは、クライアントとサーバーが最初に相互に通信するときに使用されます。 

>ハンドシェイクプロトコルにより、ピアはプロトコルバージョンをネゴシエートし、暗号化アルゴリズムを選択し、必要に応じて互いを認証し、共有秘密鍵素材を確立できます。

>ハンドシェイクが完了すると、ピアは確立されたキーを使用して、アプリケーション層のトラフィックを保護します。

>TLSは、3つの基本的なキー交換モードをサポートしています。
>- (EC)DHE（有限体または楕円曲線上のディフィー・ヘルマン）
>- PSKのみ
>- (EC)DHEを使用したPSK

>ハンドシェイクは、3つのフェーズ（上記の図に示されている）を持っていると考えることができます。
>- 鍵交換：共有鍵素材を確立し、暗号化パラメーターを選択します。 このフェーズ以降はすべて暗号化されます。
>- サーバーパラメータ：他のハンドシェイクパラメータを確立します（クライアントが認証されているかどうか、アプリケーション層プロトコルのサポートなど）。
>- 認証：サーバー（およびオプションでクライアント）を認証し、キーの確認とハンドシェイクの整合性を提供します。

## ABNF
### [RFC 5234](https://tex2e.github.io/rfc-translater/html/rfc5234.html)

## curlコマンド
- -Tでファイルをbody送信
- -Fでファイルをmultipart/form-dataでbody送信
- -c --cookie-jar でCookieを保存
- -b --cookie でCookieを送信
- --basic でbasic認証を指定　-u -user \<username>:\<passworld>
- -1 --tsl1 --tsl1.0 --tsl1.1 --tsl1.2 --tsl1.3 TLSで接続
- --cert-status 証明書を確認
- -k --inscurr オレオレ証明書でもエラーにならない